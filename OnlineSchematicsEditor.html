<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Online Schematics Editor — MVP</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#161a22; --ink:#e6e6e6; --muted:#a5adbb; --accent:#61dafb; --danger:#ff6b6b; --ok:#4ade80;
      --grid:#2a2f3a; --grid-bold:#3a4150; --wire:#c7f284; --select:#f59e0b; --pin:#93c5fd; --component:#e2e8f0; --ghost:#64748b;
    }
    html, body {height:100%;}
    body{margin:0; font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; color:var(--ink); background:var(--bg);}
    .app{display:grid; grid-template-columns: 320px 1fr 320px; grid-template-rows:auto 1fr; height:100%;}
    header{grid-column: 1/4; display:flex; align-items:center; gap:.5rem; padding:.5rem .75rem; background:var(--panel); border-bottom:1px solid #22262f; position:sticky; top:0; z-index:3}
    /* Keep everything on one row (no wrap); we'll popup sub-types absolutely */
    header{ flex-wrap: nowrap; align-items: center; }
    /* Thin vertical separator between mode buttons and components */
    .vsep{ width:1px; height:32px; background:#22262f; margin:0 .5rem; border-radius:1px; }
    /* Sub-type popup: small, only as wide as content, positioned under the Diode button */
    #paletteRow2{
      position:absolute;
      display:none;
      width:max-content;            /* only as wide as its contents */
      pointer-events:auto;
      z-index:5;                    /* above header background */
    }
    #paletteRow2 select{ width:auto; white-space:nowrap; }
    header .group{display:flex; gap:.25rem; align-items:center; background:#0e1219; padding:.25rem; border-radius:10px; border:1px solid #1e2430}
    button{appearance:none; background:#0e1219; border:1px solid #273042; color:var(--ink); padding:.45rem .6rem; border-radius:8px; cursor:pointer; font-size:.92rem}
    button:hover{border-color:#3a4a68}
    button.active{outline:2px solid var(--accent);}
    button.danger{border-color:#623; color:#ffb3c7}
    button.ok{border-color:#1b3; color:#bff7d0}
    #left, #right{background:var(--panel); border-right:1px solid #22262f;}
    #right{border-right:none; border-left:1px solid #22262f}
    #left, #right{padding:.75rem; overflow:auto}
    h2{margin:.25rem 0 .5rem; font-size:1.05rem; color:#cbd5e1}
    .row{display:flex; gap:.5rem; align-items:center; margin:.4rem 0}
    label{color:var(--muted); font-size:.9rem}
    input[type="text"], select, input[type="number"]{width:100%; background:#0e1219; color:var(--ink); border:1px solid #273042; border-radius:8px; padding:.4rem .5rem}
    input[type="file"]{width:100%}
    .hint{color:#9aa3b2; font-size:.85rem;}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; padding:.05rem .35rem; background:#0b0f16; border:1px solid #273042; border-radius:6px}
    #editorWrap{position:relative;}
    #svg{width:100%; height:calc(100vh - 64px); display:block; background:var(--bg);}
    .overlayTip{position:absolute; left:10px; bottom:10px; background:rgba(14,18,25,.75); border:1px solid #273042; padding:.35rem .5rem; border-radius:8px; font-size:.85rem}
    /* Hover cues for hit-testing feedback */
    .wire-stroke{transition:stroke .08s ease, filter .08s ease}
    .wire-stroke.hover{stroke:var(--select); filter:drop-shadow(0 0 2px rgba(245,158,11,.6))}
    /* Selected component: tint only its symbol graphics (not pins/text/hitbox) */
    #components g.comp.selected > g line,
    #components g.comp.selected > g path,
    #components g.comp.selected > g polyline,
    #components g.comp.selected > g circle {
      stroke: var(--select) !important;
      filter: drop-shadow(0 0 2px rgba(245,158,11,.6));
    }
    /* If a symbol element is filled (e.g., transistor arrow), color its fill too */
    #components g.comp.selected > g [fill="var(--component)"] {
      fill: var(--select) !important;
    }
    
    /* Keep strokes visually consistent when zooming the SVG viewBox */
    svg line, svg path, svg polyline, svg circle { vector-effect: non-scaling-stroke; }
    /* Crosshair overlay while wiring */
    body.mode-wire #svg{ cursor: crosshair; }
    /* Pan cursors */
    body.mode-pan #svg{ cursor: grab; }
    body.mode-pan.panning #svg{ cursor: grabbing; }
    /* Also show grabbing during mid-mouse pan even if not in Pan mode */
    body.panning #svg{ cursor: grabbing; }
    /* Crosshair overlay - brighter than grid, dashed, and always on top */
    .crosshair line{
      stroke: var(--select);       /* high-contrast (orange) */
      stroke-opacity: .3;
      stroke-width: 3;             /* thicker than grid */
      stroke-dasharray: 6 6;       /* clearer dashes */
      stroke-linecap: round;
      pointer-events: none;
      filter: drop-shadow(0 0 2px rgba(121, 98, 58, 0.65));
    }
    /* Marquee selection box (drawn in #overlay) */
    #overlay rect.marquee {
      fill: rgba(245, 158, 11, 0.12);   /* subtle fill */
      stroke: var(--select);
      stroke-width: 2;
      stroke-dasharray: 6 4;
      pointer-events: none;
    }
    /* Inspector value + units on a single line, no wrapping */
    #inspector .hstack{ display:flex; gap:8px; align-items:center; }
    #inspector .hstack input[type="text"]{ flex:1 1 0; min-width:0; }     /* wide value box */
    /* Units dropdown: measure to content via JS, but cap visually via CSS too */
    #inspector .hstack select{
      flex:0 0 auto;
      min-width:72px;
      max-width:50%;                 /* hard cap: never exceed half the row */
      white-space:nowrap;
      width:auto;                    /* prevent global select{width:100%} */
    }    
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="group" id="modeGroup">
      <button data-mode="select" class="active" title="Select/Move (V)">Select</button>
      <button data-mode="wire" title="Wire (W)">Wire</button>
      <button data-mode="delete" title="Delete (Del)">Delete</button>
      <button data-mode="pan" title="Pan (P or MMB drag)">Pan</button>
      <button data-mode="move" title="Move selected (M / Arrow keys)">Move</button>      
    </div>
    <div class="vsep"></div> 
    <div class="group" id="paletteRow1">
      <button data-tool="resistor" title="Place Resistor (R)">Resistor</button>
      <button data-tool="capacitor" title="Place Capacitor (C)">Capacitor</button>
      <button data-tool="inductor" title="Place Inductor (L)">Inductor</button>
      <button data-tool="diode" title="Place Diode (D)">Diode</button>
      <button data-tool="npn" title="Place NPN">NPN</button>
      <button data-tool="pnp" title="Place PNP">PNP</button>
      <button data-tool="ground" title="Place Ground">GND</button>
      <button data-tool="battery" title="Place Battery">Battery</button>
      <button data-tool="ac" title="Place AC Source">AC Source</button>
    </div>
    <!-- Sub-type row (appears when a type with subtypes is active; for now: Diode) -->
    <div class="group" id="paletteRow2" style="display:none">
      <select id="diodeSelect" title="Diode subtype">
        <option value="generic" selected>Generic</option>
        <option value="schottky">Schottky</option>
        <option value="zener">Zener</option>
        <option value="led">Light-emitting (LED)</option>
        <option value="photo">Photo</option>
        <option value="tunnel">Tunnel</option>
        <option value="varactor">Varactor / Varicap</option>
        <option value="laser">Laser</option>
      </select>
    </div>    
    <div class="group">
      <button id="rotateBtn" title="Rotate 90° (R)">Rotate</button>
      <button id="clearBtn" class="danger" title="Clear (Ctrl+K)">Clear</button>
    </div>
    <div class="group">
      <button id="zoomOutBtn" title="Zoom Out (−)">−</button>
      <button id="zoomInBtn" title="Zoom In (+)">+</button>
      <button id="zoomResetBtn" title="Reset Zoom (1:1)">100%</button>
      <input id="zoomPct" type="text" value="100%" title="Zoom % (editable)" style="width:64px;text-align:right" />      
    </div>    
    <div class="group">
      <button id="saveBtn" class="ok" title="Save JSON (Ctrl+S)">Save</button>
      <button id="loadBtn" title="Load JSON">Load</button>
      <input id="fileInput" type="file" accept="application/json" style="display:none" />
    </div>
    <div style="margin-left:auto; color:#9aa3b2">Grid: <span class="kbd">24px</span> · Snap: <span class="kbd">on</span></div>
  </header>
  <aside id="left">
    <h2>Inspector</h2>
    <div id="inspectorNone" class="hint">Select a component to edit its properties.</div>
    <div id="inspector"></div>
    <hr style="border-color:#22262f; margin:1rem 0" />
    <h2>Tips</h2>
    <ul class="hint" style="line-height:1.5">
      <li><span class="kbd">V</span> Select/Move · <span class="kbd">W</span> Wire · <span class="kbd">Del</span> Delete</li>
      <li>Click grid to place selected part. Drag to move. <span class="kbd">R</span> rotates a part.</li>
      <li>Wiring: click start → click turns → double‑click or <span class="kbd">Enter</span> to finish. <span class="kbd">Esc</span> to cancel.</li>
      <li>Select: click-drag on empty space to draw a marquee window. Release to select (by default, the nearest <em>wire segment</em> in the box). Hold <span class="kbd">Shift</span> while dragging to prefer <em>components</em> instead. Click empty space to clear.</li>
      <li>Delete: click a wire <em>segment</em> or component to remove.</li>
    </ul>
  </aside>
  <main id="center">
    <div id="editorWrap">
      <svg id="svg" viewBox="0 0 1600 1000" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <pattern id="grid" width="24" height="24" patternUnits="userSpaceOnUse">
            <path d="M24 0H0V24" fill="none" stroke="var(--grid)" stroke-width="1" />
          </pattern>
          <pattern id="gridBold" width="120" height="120" patternUnits="userSpaceOnUse">
            <rect width="120" height="120" fill="url(#grid)"/>
            <path d="M120 0H0V120" fill="none" stroke="var(--grid-bold)" stroke-width="1.5" />
          </pattern>
          <!-- Marker for wire endpoints when drawing -->
          <marker id="dot" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="5" markerHeight="5">
            <circle cx="5" cy="5" r="3" fill="var(--wire)" />
          </marker>
        </defs>
        <rect id="gridRect" x="0" y="0" width="1600" height="1000" fill="url(#gridBold)" />
        <g id="wires"></g>
        <g id="components"></g>
        <g id="drawing"></g>
        <g id="overlay" class="crosshair"></g>
      </svg>
      <div class="overlayTip" id="overlayTip">Mode: <b id="modeLabel">Select</b></div>
    </div>
  </main>
  <aside id="right">
    <h2>Project</h2>
    <div class="row"><label>Title</label></div>
    <div class="row"><input id="projTitle" type="text" placeholder="Untitled schematic" /></div>
    <div class="row hint">Saved into JSON</div>
    <hr style="border-color:#22262f; margin:1rem 0" />
    <h2>Counts</h2>
    <div class="hint" id="counts">—</div>
  </aside>
</div>

<script>
(function(){
  // ====== Core State ======
  const GRID = 24; // px
  const svg = document.getElementById('svg');
  const gWires = document.getElementById('wires');
  const gComps = document.getElementById('components');
  const gDrawing = document.getElementById('drawing');
  const gOverlay = document.getElementById('overlay');  
  const inspector = document.getElementById('inspector');
  const inspectorNone = document.getElementById('inspectorNone');
  const projTitle = document.getElementById('projTitle');
  const countsEl = document.getElementById('counts');
  const overlayMode = document.getElementById('modeLabel');

  /** @type {Array<{id:string,type:string,x:number,y:number,rot:number,label:string,value?:string,props?:any}>} */
  let components = [];
  /** @type {Array<{id:string,points:{x:number,y:number}[]}>} */
  let wires = [];

  let mode = 'select'; // 'select' | 'wire' | 'delete' | 'place'
  let placeType = null; // when mode=='place'
  // selection optionally includes segIndex for wire-segment selection
  let selection = { kind: null, id: null, segIndex: null }; // {kind:'component'|'wire', id, segIndex?}
  let drawing = { active:false, points:[], cursor:null }; // cursor = live rubber-band point
  // Marquee selection (click+drag rectangle) state
  let marquee = { active:false, start:null, end:null, rectEl:null, startedOnEmpty:false, shiftPreferComponents:false };
  // Suppress the next contextmenu after right-click finishing a wire
  let suppressNextContextMenu = false;
  // ViewBox zoom state
  const BASE_W = 1600, BASE_H = 1000;
  let zoom = 1;
  let viewX = 0, viewY = 0; // pan in SVG units
  let viewW = BASE_W, viewH = BASE_H; // effective viewBox size (updated by applyZoom)
  function applyZoom() {
    // Match the SVG element's current aspect ratio so the grid fills the canvas (no letterboxing)
    const vw = Math.max(1, svg.clientWidth);
    const vh = Math.max(1, svg.clientHeight);
    const aspect = vw / vh;
    viewW = BASE_W / zoom;
    viewH = viewW / aspect;              // compute height from live aspect
    svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewW} ${viewH}`);
    redrawGrid();
    updateZoomUI();
  }
  // keep grid filling canvas on window resizes
  window.addEventListener('resize', applyZoom);
  function redrawGrid(){
    const w = viewW, h = viewH;
    const r = document.getElementById('gridRect');
    if(!r) return;
    r.setAttribute('x', viewX);
    r.setAttribute('y', viewY);
    r.setAttribute('width', w);
    r.setAttribute('height', h);
  }
  function updateZoomUI(){
    const z = Math.round(zoom * 100);
    const inp = document.getElementById('zoomPct');
    if (inp && inp.value !== z + '%') inp.value = z + '%';
  }

  let counters = { resistor:1, capacitor:1, inductor:1, diode:1, npn:1, pnp:1, ground:1, battery:1, ac:1, wire:1 };
  // Palette state: diode subtype selection
  let diodeSubtype = 'generic';

  // ====== Unit options for Value fields ======
  const UNIT_OPTIONS = {
    resistor: ['T\u03A9','G\u03A9','M\u03A9','k\u03A9','\u03A9','m\u03A9'],                // TΩ … mΩ
    capacitor: ['TF','GF','MF','kF','F','mF','\u00B5F','nF','pF'],                        // µ = \u00B5
    inductor: ['TH','GH','MH','kH','H','mH','\u00B5H','nH']                               // µ = \u00B5
  };


  const snap = v => Math.round(v/GRID)*GRID;
  const uid = (prefix)=> `${prefix}${counters[prefix]++}`;

  function updateCounts(){
    countsEl.textContent = `Components: ${components.length} · Wires: ${wires.length}`;
  }

  function setMode(m){
    mode = m; overlayMode.textContent = m[0].toUpperCase()+m.slice(1);
    document.querySelectorAll('#modeGroup button').forEach(b=>b.classList.toggle('active', b.dataset.mode===m));
    // reflect mode on body for cursor styles
    document.body.classList.remove('mode-select','mode-wire','mode-delete','mode-place','mode-pan','mode-move');
    document.body.classList.add(`mode-${m}`);
    // If user switches to Delete with an active selection, apply delete immediately
    if (m==='delete' && selection.kind){
      if(selection.kind==='component'){ removeComponent(selection.id); return; }
      if(selection.kind==='wire'){
        const w = wires.find(x=>x.id===selection.id);
        if(w && Number.isInteger(selection.segIndex)){
          removeWireSegment(w, selection.segIndex);
        } else if (w){
          wires = wires.filter(x=>x.id!==w.id);
          selection={kind:null,id:null,segIndex:null};
          redraw();
        }
        return;
      }
    }
    redraw(); // refresh wire/comp hit gating for the new mode    
  }

  // ====== Component Drawing ======
  function compPinPositions(c){
    // two-pin components: pins at +/- 2*GRID along the component rotation axis
    const r = ((c.rot % 360) + 360) % 360;
    if(c.type==='npn' || c.type==='pnp'){      // base at center; collector top; emitter bottom (before rotation)
      const pins = [ {name:'B', x:c.x, y:c.y}, {name:'C', x:c.x, y:c.y-2*GRID}, {name:'E', x:c.x, y:c.y+2*GRID} ];
      return pins.map(p=>rotatePoint(p, {x:c.x, y:c.y}, r));
    } else if (c.type==='ground') {
      // single pin at top of ground symbol
      return [ {name:'G', x:c.x, y:c.y - 2} ];
    } else {      
      // Generic 2-pin (resistor, capacitor, inductor, diode, battery, ac)
      const L = 2*GRID;
      const rad = r * Math.PI/180;
      const ux = Math.cos(rad), uy = Math.sin(rad);
      const a = { x: c.x - L*ux, y: c.y - L*uy, name:'A' };
      const b = { x: c.x + L*ux, y: c.y + L*uy, name:'B' };
      return [a,b];      
    }
  }

  function rotatePoint(p, center, deg){
    const rad = deg*Math.PI/180; const s=Math.sin(rad), co=Math.cos(rad);
    const dx=p.x-center.x, dy=p.y-center.y;
    return { x: center.x + dx*co - dy*s, y: center.y + dx*s + dy*co, name:p.name };
  }

  function drawComponent(c){
    if(!c.props) c.props = {};
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('comp');
    g.setAttribute('data-id', c.id);

    // (selection ring removed; selection is shown by tinting the symbol graphics)

    // big invisible hit for easy click/drag
    const hit = document.createElementNS('http://www.w3.org/2000/svg','rect');
    hit.setAttribute('x', c.x-60); hit.setAttribute('y', c.y-60);
    hit.setAttribute('width', 120); hit.setAttribute('height', 120);
    hit.setAttribute('fill','transparent');
    g.appendChild(hit);

    // pins
    compPinPositions(c).forEach((p,idx)=>{
      const pin = document.createElementNS('http://www.w3.org/2000/svg','circle');
      pin.setAttribute('cx', p.x); pin.setAttribute('cy', p.y);
      pin.setAttribute('r', 3); pin.setAttribute('fill', 'var(--node)');
      pin.setAttribute('data-pin', String(idx));
      g.appendChild(pin);
    });

    // hover cue
    g.addEventListener('pointerenter', ()=>{ g.classList.add('comp-hover'); });
    g.addEventListener('pointerleave', ()=>{ g.classList.remove('comp-hover'); });

    // Components should not block clicks when wiring or placing
    g.style.pointerEvents = (mode==='wire' || mode==='place') ? 'none' : 'auto';

    // ---- Drag + selection (mouse) ----
    let dragging=false, dragOff={x:0,y:0}, slideCtx=null, dragStart=null;
    g.addEventListener('pointerdown', (e)=>{
      if(mode==='delete'){ removeComponent(c.id); return; }
      if(!(mode==='select' || mode==='move')) return;
      if(e.button!==0) return;
      // persist selection until user clicks elsewhere
      selection = {kind:'component', id:c.id, segIndex:null};
      renderInspector(); updateSelectionOutline();
      dragging=true;
      const pt = svgPoint(e);
      dragOff.x = c.x - pt.x; dragOff.y = c.y - pt.y;
      slideCtx = buildSlideContext(c);
      const pins0 = compPinPositions(c).map(p=>({x:snap(p.x),y:snap(p.y)}));
      const wsA = wiresEndingAt(pins0[0]);
      const wsB = wiresEndingAt(pins0[1]||pins0[0]);
      dragStart = {
        x:c.x, y:c.y, pins:pins0,
        embedded:(wsA.length===1 && wsB.length===1),
        wA: wsA[0]||null, wB: wsB[0]||null
      };
      e.preventDefault();
      if (typeof g.setPointerCapture === 'function' && e.isPrimary) {
        try { g.setPointerCapture(e.pointerId); } catch(_) {}
      }
      e.stopPropagation();
    });
    g.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const p = svgPoint(e);
      if(slideCtx){
        if(slideCtx.axis==='x'){
          let nx = snap(p.x + dragOff.x);
          nx = Math.max(Math.min(slideCtx.max, nx), slideCtx.min);
          c.x = nx; c.y = slideCtx.fixed;
        }else{
          let ny = snap(p.y + dragOff.y);
          ny = Math.max(Math.min(slideCtx.max, ny), slideCtx.min);
          c.y = ny; c.x = slideCtx.fixed;
        }
        const pinsNow = compPinPositions(c).map(p=>({x:snap(p.x),y:snap(p.y)}));
        adjustWireEnd(slideCtx.wA, slideCtx.pinAStart, pinsNow[0]);
        adjustWireEnd(slideCtx.wB, slideCtx.pinBStart, pinsNow[1]);
        slideCtx.pinAStart = pinsNow[0]; slideCtx.pinBStart = pinsNow[1];
        updateComponentDOM(c); updateWireDOM(slideCtx.wA); updateWireDOM(slideCtx.wB);
      }else{
        c.x = snap(p.x + dragOff.x);
        c.y = snap(p.y + dragOff.y);
        updateComponentDOM(c);
      }
    });
    g.addEventListener('pointerup', (e)=>{
      if (typeof g.releasePointerCapture === 'function' && e.isPrimary) {
        try { g.releasePointerCapture(e.pointerId); } catch(_) {}
      }
      if(!dragging) return;
      dragging=false;
      if(dragStart){
        if(overlapsAnyOther(c)){
          c.x = dragStart.x; c.y = dragStart.y;
          if(slideCtx && dragStart.pins?.length===2){
            adjustWireEnd(slideCtx.wA, slideCtx.pinAStart, dragStart.pins[0]);
            adjustWireEnd(slideCtx.wB, slideCtx.pinBStart, dragStart.pins[1]);
          }
          updateComponentDOM(c);
          if(slideCtx){ updateWireDOM(slideCtx.wA); updateWireDOM(slideCtx.wB); }
        }else{
          if(!dragStart.embedded){
            const didBreak = breakWiresForComponent(c);
            if(didBreak){ deleteBridgeBetweenPins(c); redraw(); }
            else { updateComponentDOM(c); }
          }else{
            updateComponentDOM(c);
            if(slideCtx){ updateWireDOM(slideCtx.wA); updateWireDOM(slideCtx.wB); }
          }
        }
        dragStart=null;
      }
    });
    g.addEventListener('pointercancel', ()=>{ dragging=false; });

    // draw symbol via helper
    g.appendChild(buildSymbolGroup(c));
    return g;
  }

  // Build a fresh SVG group for a component’s symbol and label text.
  function buildSymbolGroup(c){
    const gg = document.createElementNS('http://www.w3.org/2000/svg','g');
    gg.setAttribute('transform', `rotate(${c.rot} ${c.x} ${c.y})`);
    const add = (el)=>{ gg.appendChild(el); return el; };
    const line = (x1,y1,x2,y2)=>{ const ln = document.createElementNS('http://www.w3.org/2000/svg','line'); ln.setAttribute('x1',x1); ln.setAttribute('y1',y1); ln.setAttribute('x2',x2); ln.setAttribute('y2',y2); ln.setAttribute('stroke','var(--component)'); ln.setAttribute('stroke-width','2'); return add(ln); };
    const path = (d)=>{ const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill','none'); p.setAttribute('stroke','var(--component)'); p.setAttribute('stroke-width','2'); return add(p); };

    // two-pin lead stubs
    if(['resistor','capacitor','inductor','diode','battery','ac'].includes(c.type)){
      const ax = c.x - 48, bx = c.x + 48, y = c.y;
      line(ax, y, ax+12, y); line(bx-12, y, bx, y);
    }
    if(c.type==='resistor'){
      const y=c.y, x=c.x-36;
      path(`M ${x} ${y} l 8 -10 l 8 20 l 8 -20 l 8 20 l 8 -20 l 8 20 l 8 -10`);
    }
    if(c.type==='capacitor'){
      const y=c.y, x1=c.x-8, x2=c.x+8;
      line(x1, y-16, x1, y+16);
      line(x2, y-16, x2, y+16);
    }
    if(c.type==='inductor'){
      const y=c.y, start=c.x-28, r=8; let d=`M ${start} ${y}`;
      for(let i=0;i<5;i++) d += ` q ${r} -${r} ${r*2} 0`;
      path(d);
    }
    if(c.type==='diode'){
      // subtype-aware diode rendering
      drawDiodeInto(gg, c, (c.props && c.props.subtype) ? c.props.subtype : 'generic');      
    }
    if(c.type==='battery'){
      const y=c.y, xLong=c.x-10, xShort=c.x+6;
      line(xLong, y-18, xLong, y+18);
      line(xShort, y-12, xShort, y+12);
    }
    if(c.type==='ac'){
      const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circ.setAttribute('cx', c.x); circ.setAttribute('cy', c.y); circ.setAttribute('r', 14);
      circ.setAttribute('fill','none'); circ.setAttribute('stroke','var(--component)'); circ.setAttribute('stroke-width','2');
      gg.appendChild(circ);
      path(`M ${c.x-10} ${c.y} q 5 -8 10 0 q 5 8 10 0`);
    }
    if(c.type==='npn' || c.type==='pnp'){
      const x=c.x, y=c.y, arrowOut = c.type==='npn';
      line(x, y-28, x, y+28);         // base
      line(x, y-10, x+30, y-30);      // collector
      line(x, y+10, x+30, y+30);      // emitter
      const arr = document.createElementNS('http://www.w3.org/2000/svg','path');
      const dx = arrowOut ? 8 : -8;
      arr.setAttribute('d', `M ${x+30} ${y+30} l ${-dx} -6 l 0 12 Z`);
      arr.setAttribute('fill','var(--component)'); gg.appendChild(arr);
    }
    if(c.type==='ground'){
      const y=c.y, x=c.x;
      line(x-16, y,   x+16, y);
      line(x-10, y+6, x+10, y+6);
      line(x-4,  y+12, x+4, y+12);
    }
    // label (and optional voltage line)
    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', c.x); label.setAttribute('y', c.y+46);
    label.setAttribute('text-anchor','middle'); label.setAttribute('font-size','12'); label.setAttribute('fill','var(--ink)');
    const valText = formatValue(c);
    label.textContent = valText ? `${c.label} (${valText})` : c.label;
    gg.appendChild(label);
    if(c.type==='battery' || c.type==='ac'){
      const vtxt = document.createElementNS('http://www.w3.org/2000/svg','text');
      vtxt.setAttribute('x', c.x); vtxt.setAttribute('y', c.y+62);
      vtxt.setAttribute('text-anchor','middle'); vtxt.setAttribute('font-size','12'); vtxt.setAttribute('fill','var(--ink)');
      const v = (c.props && (c.props.voltage ?? '') !== '') ? `${c.props.voltage} V` : '';
      vtxt.textContent = v; gg.appendChild(vtxt);
    }
    return gg;
  }

  // Draw diode into existing symbol group 'gg' honoring rotation already set on gg.
  function drawDiodeInto(gg, c, subtype){
    const stroke='var(--component)'; const sw=2;
    const add = (el)=>{ gg.appendChild(el); return el; };
    const mk = (tag)=> document.createElementNS('http://www.w3.org/2000/svg', tag);
    const lineEl = (x1,y1,x2,y2,w=sw)=>{ const ln=mk('line'); ln.setAttribute('x1',x1); ln.setAttribute('y1',y1); ln.setAttribute('x2',x2); ln.setAttribute('y2',y2); ln.setAttribute('stroke',stroke); ln.setAttribute('stroke-width',w); ln.setAttribute('fill','none'); return add(ln); };
    const pathEl = (d,w=sw)=>{ const p=mk('path'); p.setAttribute('d',d); p.setAttribute('stroke',stroke); p.setAttribute('stroke-width',w); p.setAttribute('fill','none'); return add(p); };
    // Base geometry around center
    const y=c.y, xTri=c.x-24;
    // Triangle (anode) and bar (cathode)
    pathEl(`M ${xTri} ${y-16} L ${xTri} ${y+16} L ${c.x} ${y} Z`);
    lineEl(c.x+8, y-16, c.x+8, y+16); // cathode bar
    // Subtype adorners near cathode side
    const cx=c.x+8, cy=y;
    const addArrow = (outward=true)=>{
      const dir = outward ? 1 : -1, ax = cx + (outward?10:-10);
      pathEl(`M ${ax} ${cy-10} l ${6*dir} -6 m -6 6 l ${6*dir} 6`);
      pathEl(`M ${ax} ${cy+10} l ${6*dir} -6 m -6 6 l ${6*dir} 6`);
    };
    switch(String(subtype||'generic').toLowerCase()){
      case 'zener':
        // Bent cathode: two short slanted ticks into bar
        lineEl(cx-14, cy-6, cx, cy);
        lineEl(cx-14, cy+6, cx, cy);
        break;
      case 'schottky':
        // Schottky: small second bar close to cathode
        lineEl(cx-6, cy-12, cx-6, cy+12);
        break;
      case 'led':
        addArrow(true);
        break;
      case 'photo':
        addArrow(false);
        break;
      case 'tunnel':
        // Tunnel/Esaki: extra vertical bar near cathode
        lineEl(cx-10, cy-12, cx-10, cy+12);
        break;
      case 'varactor':
      case 'varicap':
        // Varactor: parallel plate near cathode (capacitor-like)
        lineEl(cx+8, cy-12, cx+8, cy+12);
        break;
      case 'laser':
        // Laser diode: LED arrows + cavity line
        addArrow(true);
        lineEl(cx+14, cy-14, cx+14, cy+14);
        break;
      case 'generic':
      default:
        // no extra marks
        break;
    }
  }  

  function redrawCanvasOnly(){
    // components
    gComps.replaceChildren();
    for(const c of components){ gComps.appendChild(drawComponent(c)); }
    // wires (with wide, nearly-transparent hit-target + hover cue)
    gWires.replaceChildren();
    for (const w of wires){
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('data-id', w.id);

      // visible stroke
      const vis = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      vis.setAttribute('class','wire-stroke');
      vis.setAttribute('fill','none');
      vis.setAttribute('stroke','var(--wire)');
      vis.setAttribute('stroke-width','3');
      vis.setAttribute('stroke-linecap','round');
      vis.setAttribute('stroke-linejoin','round');
      vis.setAttribute('points', w.points.map(p=>`${p.x},${p.y}`).join(' '));
      vis.setAttribute('data-wire-stroke', w.id);
      // visible stroke must NOT catch events—let the hit overlay do it
      vis.setAttribute('pointer-events','none');

      // transparent hit overlay (easy clicking)
      const hit = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      hit.setAttribute('fill','none');
      hit.setAttribute('stroke','#000');
      hit.setAttribute('stroke-opacity','0.001'); // capture events reliably
      hit.setAttribute('stroke-width','24');
      // GATE POINTER EVENTS: hit overlay disabled during Wire/Place so it doesn't block clicks
      const allowHits = (mode!=='wire' && mode!=='place');
      hit.setAttribute('pointer-events', allowHits ? 'stroke' : 'none');
      hit.setAttribute('points', vis.getAttribute('points')); // IMPORTANT: give the hit polyline geometry

      // interactions
      hit.addEventListener('pointerenter', ()=>{ if(allowHits) vis.classList.add('hover'); });
      hit.addEventListener('pointerleave', ()=>{ if(allowHits) vis.classList.remove('hover'); });
      hit.addEventListener('pointerdown', (e)=>{
        if (mode === 'delete') { removeWireAtPoint(w, svgPoint(e)); }
        else if (mode === 'select' || mode==='move') {
          const idx = nearestSegmentIndex(w.points, svgPoint(e));
          selecting('wire', w.id, idx);
        }      
        e.stopPropagation();
      });

      g.appendChild(hit);
      g.appendChild(vis);
      // persistent selection highlight for a specific wire segment
      if (selection.kind==='wire' && selection.id===w.id && Number.isInteger(selection.segIndex)) {
        const i = selection.segIndex;
        if (i>=0 && i < w.points.length-1){
          const a = w.points[i], b = w.points[i+1];
          const selSeg = document.createElementNS('http://www.w3.org/2000/svg','line');
          selSeg.setAttribute('x1', a.x); selSeg.setAttribute('y1', a.y);
          selSeg.setAttribute('x2', b.x); selSeg.setAttribute('y2', b.y);
          selSeg.setAttribute('stroke','var(--select)');
          selSeg.setAttribute('stroke-width','6');
          selSeg.setAttribute('stroke-linecap','round');
          selSeg.setAttribute('pointer-events','none');
          g.appendChild(selSeg);
        }
      }      
      gWires.appendChild(g);
    }
    updateSelectionOutline();    
    updateCounts();
  }

  function redraw(){
    redrawCanvasOnly();
    renderInspector();
  }

  // Update selection styling (no circle; tint symbol graphics via CSS)
  function updateSelectionOutline(){
    document.querySelectorAll('#components g.comp').forEach(g=>{
      const id = g.getAttribute('data-id');
      const on = selection.kind==='component' && selection.id===id;
      g.classList.toggle('selected', !!on);
    });    
  }  

  function selecting(kind, id, segIndex=null){ selection = {kind, id, segIndex}; redraw(); }

  function removeComponent(id){
    const comp = components.find(c=>c.id===id);
    // Mend only for simple 2-pin parts
    if (comp && ['resistor','capacitor','inductor','diode','battery','ac'].includes(comp.type)) {
      const pins = compPinPositions(comp).map(p=>({ x:snap(p.x), y:snap(p.y) }));
      if (pins.length === 2) {
        const axis = axisFromPins(pins);
        const wA = wireAlongAxisAt(pins[0], axis);
        const wB = wireAlongAxisAt(pins[1], axis);
        if (wA && wB){
          // Reconstruct a single wire by concatenating the two polylines at the gap.
          // We do NOT jump to far endpoints; we join using each side’s vertices next to the pin.
          const aPoints = orderPointsEndingAt(wA.points, pins[0]); // ... , pin
          const bPoints = orderPointsStartingAt(wB.points, pins[1]); // pin , ...
          // Drop the pins, then join: [...A_without_pin, ...B_without_pin]
          const left  = aPoints.slice(0, aPoints.length - 1); // up to (but not including) pin
          const right = bPoints.slice(1);                     // from first after pin
          const joined = left.concat(right);
          // If the join introduces duplicate vertex, collapse it
          const merged = collapseDuplicateVertices(joined);
          // Replace the two wires with a single merged polyline
          wires = wires.filter(w => w!==wA && w!==wB);
          wires.push({ id: uid('wire'), points: merged });
        }
      }
    }
    components = components.filter(c => c.id !== id);
    if (selection.id === id) selection = { kind:null, id:null, segIndex:null };
    redraw();
  }

  function removeWireAtPoint(w, p){
    // Delete ONLY the clicked segment; split at nearest segment index.
    const idx = nearestSegmentIndex(w.points, p);
    if (idx < 0 || idx >= w.points.length - 1) return;
    removeWireSegment(w, idx);
  }

  function removeWireSegment(w, idx){
    if(!w) return;
    if (idx < 0 || idx >= w.points.length - 1) return;
     const left = w.points.slice(0, idx + 1);   // up to the start of removed seg (no segment if len<2)
     const right = w.points.slice(idx + 1);     // from end of removed seg
     // Remove original wire
     wires = wires.filter(x => x.id !== w.id);
     // Add split pieces back if they contain at least one segment
     const L = normalizedPolylineOrNull(left);
     const R = normalizedPolylineOrNull(right);
     if (L) wires.push({ id: uid('wire'), points: L });
     if (R) wires.push({ id: uid('wire'), points: R }); 
     if (selection.id === w.id) selection = { kind:null, id:null, segIndex:null };
     redraw();
   }  

  // Format value+unit shown on the schematic label line
  function formatValue(c){
    const v = (c.value ?? '').toString().trim();
    if(!v) return '';
    if(c.type==='resistor'){
      const u = (c.props && c.props.unit) || '\u03A9'; // Ω
      return `${v} ${u}`;
    }
    if(c.type==='capacitor'){
      const u = (c.props && c.props.unit) || 'F';
      return `${v} ${u}`;
    }
    if(c.type==='inductor'){
      const u = (c.props && c.props.unit) || 'H';
      return `${v} ${u}`;
    }
    return v;
  }  

  function nearestSegmentIndex(pts, p){
    let best=-1, bestD=1e9;
    for(let i=0;i<pts.length-1;i++){
      const d = pointToSegmentDistance(p, pts[i], pts[i+1]);
      if(d<bestD){ bestD=d; best=i; }
    }
    return best;
  }

  function pointToSegmentDistance(p, a, b){
    const A = {x:a.x, y:a.y}, B={x:b.x, y:b.y}, P={x:p.x, y:p.y};
    const ABx=B.x-A.x, ABy=B.y-A.y; const APx=P.x-A.x, APy=P.y-A.y;
    const ab2 = ABx*ABx + ABy*ABy; if(ab2===0) return Math.hypot(APx,APy);
    let t = (APx*ABx + APy*ABy)/ab2; t=Math.max(0, Math.min(1,t));
    const Qx=A.x + t*ABx, Qy=A.y + t*ABy; return Math.hypot(P.x-Qx, P.y-Qy);
  }

  function projectPointToSegment(p, a, b){
    const A={x:a.x,y:a.y}, B={x:b.x,y:b.y}, P={x:p.x,y:p.y};
    const ABx=B.x-A.x, ABy=B.y-A.y; const APx=P.x-A.x, APy=P.y-A.y;
    const ab2 = ABx*ABx + ABy*ABy; if(ab2===0) return {q:{x:A.x,y:A.y}, t:0};
    let t = (APx*ABx + APy*ABy)/ab2; t=Math.max(0, Math.min(1,t));
    return { q:{ x:A.x + t*ABx, y:A.y + t*ABy }, t };
  }

  // Angles / nearest segment helpers
  const deg = (rad)=> rad*180/Math.PI;
  const normDeg = (d)=> ((d%360)+360)%360;
  const isTwoPinType = (t)=> ['resistor','capacitor','inductor','diode','battery','ac'].includes(t);
  function segmentAngle(a,b){ return deg(Math.atan2(b.y-a.y, b.x-a.x)); }
  function nearestSegmentAtPoint(p, maxDist=18){
    let best=null, bestD=Infinity;
    for(const w of wires){
      for(let i=0;i<w.points.length-1;i++){
        const a=w.points[i], b=w.points[i+1];
        const {q,t} = projectPointToSegment(p,a,b);
        if(t<=0 || t>=1) continue; // interior only
        const d = Math.hypot(p.x-q.x, p.y-q.y);
        if(d<bestD){ bestD=d; best={w, idx:i, q, angle: segmentAngle(a,b)}; }
      }
    }
    return (best && bestD<=maxDist) ? best : null;
  }  

  // ----- Marquee helpers -----
  const rectFromPoints = (a,b)=>{
    const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
    return { x, y, w: Math.abs(a.x-b.x), h: Math.abs(a.y-b.y) };
  };
  const inRect = (p, r)=> p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h;
  function segsIntersect(p1,p2,q1,q2){
    const o = (a,b,c)=>Math.sign((b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x));
    const on = (a,b,c)=> Math.min(a.x,b.x)<=c.x && c.x<=Math.max(a.x,b.x) && Math.min(a.y,b.y)<=c.y && c.y<=Math.max(a.y,b.y);
    const o1=o(p1,p2,q1), o2=o(p1,p2,q2), o3=o(q1,q2,p1), o4=o(q1,q2,p2);
    if(o1!==o2 && o3!==o4) return true;
    if(o1===0 && on(p1,p2,q1)) return true;
    if(o2===0 && on(p1,p2,q2)) return true;
    if(o3===0 && on(q1,q2,p1)) return true;
    if(o4===0 && on(q1,q2,p2)) return true;
    return false;
  }
  function segmentIntersectsRect(a,b,r){
    if(inRect(a,r) || inRect(b,r)) return true;
    const R = [{x:r.x,y:r.y},{x:r.x+r.w,y:r.y},{x:r.x+r.w,y:r.y+r.h},{x:r.x,y:r.y+r.h}];
    return segsIntersect(a,b,R[0],R[1]) || segsIntersect(a,b,R[1],R[2]) ||
           segsIntersect(a,b,R[2],R[3]) || segsIntersect(a,b,R[3],R[0]);
  }
  function beginMarqueeAt(p, startedOnEmpty, preferComponents){
    marquee.active = true; marquee.start = p; marquee.end = p; marquee.startedOnEmpty = !!startedOnEmpty;
    marquee.shiftPreferComponents = !!preferComponents;  
    if(marquee.rectEl) marquee.rectEl.remove();
    marquee.rectEl = document.createElementNS('http://www.w3.org/2000/svg','rect');
    marquee.rectEl.setAttribute('class','marquee');
    gOverlay.appendChild(marquee.rectEl);
    updateMarqueeTo(p);
  }
  function updateMarqueeTo(p){
    if(!marquee.active) return;
    marquee.end = p;
    const r = rectFromPoints(marquee.start, marquee.end);
    marquee.rectEl.setAttribute('x', r.x); marquee.rectEl.setAttribute('y', r.y);
    marquee.rectEl.setAttribute('width', r.w); marquee.rectEl.setAttribute('height', r.h);
  }
  function finishMarquee(){
    if(!marquee.active) return false;
    const r = rectFromPoints(marquee.start, marquee.end);
    const movedEnough = (Math.abs(r.w) > 2 || Math.abs(r.h) > 2);
    // remove rect
    marquee.rectEl?.remove(); marquee.rectEl=null;
    marquee.active=false;
    // If it wasn't really a drag, treat it as a normal empty click
    if(!movedEnough){
      if(marquee.startedOnEmpty){
        selection = {kind:null,id:null,segIndex:null};
        redraw();
      }
      return false;
    }
    // Build candidates once
    const cx = r.x + r.w/2, cy = r.y + r.h/2;
    const segs = [];
    for(const w of wires){
      for(let i=0;i<w.points.length-1;i++){
        const a=w.points[i], b=w.points[i+1];
        if(segmentIntersectsRect(a,b,r)){
          const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
          const d2=(mx-cx)*(mx-cx)+(my-cy)*(my-cy);
          segs.push({w, idx:i, d2});
        }
      }
    }
    const comps = [];
    for(const c of components){
      if(inRect({x:c.x,y:c.y}, r)){
        const d2=(c.x-cx)*(c.x-cx)+(c.y-cy)*(c.y-cy);
        comps.push({c,d2});
      }
    }
    // Decide priority based on Shift during drag
    const preferComponents = !!marquee.shiftPreferComponents;
    if(preferComponents){
      if(comps.length){
        comps.sort((u,v)=>u.d2-v.d2);
        selection = {kind:'component', id:comps[0].c.id, segIndex:null};
        redraw(); return true;
      }
      if(segs.length){
        segs.sort((u,v)=>u.d2-v.d2);
        const pick = segs[0];
        selection = {kind:'wire', id:pick.w.id, segIndex:pick.idx};
        redraw(); return true;
      }
    }else{
      if(segs.length){
        segs.sort((u,v)=>u.d2-v.d2);
        const pick = segs[0];
        selection = {kind:'wire', id:pick.w.id, segIndex:pick.idx};
        redraw(); return true;
      }
      if(comps.length){
        comps.sort((u,v)=>u.d2-v.d2);
        selection = {kind:'component', id:comps[0].c.id, segIndex:null};
        redraw(); return true;
      }
    }    
    // Nothing hit: clear selection
    selection = {kind:null,id:null,segIndex:null};
    redraw();
    return false;
  }

  function breakWiresForComponent(c){
    // Break wires at EACH connection pin (not at component center)
    let broke=false;
    const pins = compPinPositions(c);
    for (const pin of pins){
      if(breakNearestWireAtPin(pin)) broke=true;
    }
    return broke;
  }
  function breakNearestWireAtPin(pin){
    // search all wires/segments for nearest to this pin; split if close
    for(const w of [...wires]){
      for(let i=0;i<w.points.length-1;i++){
        const a=w.points[i], b=w.points[i+1];
        const {q,t} = projectPointToSegment(pin,a,b);
        const dist = pointToSegmentDistance(pin,a,b);
        // axis-aligned fallback for robust vertical/horizontal splitting
        const isVertical = (a.x===b.x);
        const isHorizontal = (a.y===b.y);
        const withinVert = isVertical && Math.abs(pin.x - a.x) <= GRID/2 && pin.y >= Math.min(a.y,b.y) && pin.y <= Math.max(a.y,b.y);
        const withinHorz = isHorizontal && Math.abs(pin.y - a.y) <= GRID/2 && pin.x >= Math.min(a.x,b.x) && pin.x <= Math.max(a.x,b.x);
        const nearInterior = (t>0.001 && t<0.999 && dist <= 20);        
        if( withinVert || withinHorz || nearInterior ){
          // For angled (nearInterior), split at the exact projection q; else use snapped pin
          const bp = nearInterior ? {x:q.x, y:q.y} : {x:snap(pin.x), y:snap(pin.y)};
          const left  = w.points.slice(0,i+1).concat([bp]);
          const right = [bp].concat(w.points.slice(i+1));
          // replace original with normalized children (drop degenerate)
          wires = wires.filter(x=>x.id!==w.id);
          const L = normalizedPolylineOrNull(left);
          const R = normalizedPolylineOrNull(right);
          if (L) wires.push({ id: uid('wire'), points: L });
          if (R) wires.push({ id: uid('wire'), points: R });
          return true;
        }
      }
    }
    return false;
  }
  // Remove the small bridge wire between the two pins of a 2-pin part
  function deleteBridgeBetweenPins(c){
    const twoPin = ['resistor','capacitor','inductor','diode','battery','ac'];
    if(!twoPin.includes(c.type)) return;
    const pins = compPinPositions(c);
    if(pins.length !== 2) return;
    const a = {x:pins[0].x, y:pins[0].y};
    const b = {x:pins[1].x, y:pins[1].y};
    const EPS = 1e-3;
    const eq = (p,q)=> Math.abs(p.x-q.x)<EPS && Math.abs(p.y-q.y)<EPS;
    wires = wires.filter(w=>{
      if(w.points.length!==2) return true;
      const p0=w.points[0], p1=w.points[1];
      const isBridge = (eq(p0,a)&&eq(p1,b)) || (eq(p0,b)&&eq(p1,a));
      return !isBridge;
    });
  }  

  // ====== SVG helpers ======
  function svgPoint(evt){
    const pt = svg.createSVGPoint();
    pt.x = (evt.clientX ?? evt.touches?.[0]?.clientX ?? 0);
    pt.y = (evt.clientY ?? evt.touches?.[0]?.clientY ?? 0);
    const ctm = svg.getScreenCTM();
    return pt.matrixTransform(ctm.inverse());
  }

  // ----- Slide helpers (simple case: each pin terminates one 2-point, axis-aligned wire) -----
  const eqPt = (p,q)=> p.x===q.x && p.y===q.y;
  function wiresEndingAt(pt){
    return wires.filter(w=>{
      const a=w.points[0], b=w.points[w.points.length-1];
      return eqPt(a,pt) || eqPt(b,pt);
    });
  }
  function otherEnd(w, endPt){
    const a=w.points[0], b=w.points[w.points.length-1];
    return eqPt(a,endPt)? b : a;
  }
  function otherEndpointOf(w, endPt){
    const a=w.points[0], b=w.points[w.points.length-1];
    return eqPt(a,endPt)? b : a;
  }  
  function adjacentOther(w, endPt){
    // return the vertex adjacent to the endpoint that equals endPt
    const n = w.points.length;
    if(n<2) return null;
    if(eqPt(w.points[0], endPt)) return w.points[1];
    if(eqPt(w.points[n-1], endPt)) return w.points[n-2];
    return null;
  }  

  function buildSlideContext(c){
    // only for simple 2-pin parts
    if(!['resistor','capacitor','inductor','diode','battery','ac'].includes(c.type)) return null;
    const pins = compPinPositions(c).map(p=>({x:snap(p.x),y:snap(p.y)}));
    if(pins.length!==2) return null;
    const axis = axisFromPins(pins);
    if(!axis) return null;
    const wA = wireAlongAxisAt(pins[0], axis);
    const wB = wireAlongAxisAt(pins[1], axis);
    if(!wA || !wB) return null;
    const aAdj = adjacentOther(wA, pins[0]);
    const bAdj = adjacentOther(wB, pins[1]);
    if(!aAdj || !bAdj) return null;
    if(axis==='x'){
      const fixed = pins[0].y;
      const min = Math.min(aAdj.x, bAdj.x);
      const max = Math.max(aAdj.x, bAdj.x);
      return {axis:'x', fixed, min, max, wA, wB, pinAStart:pins[0], pinBStart:pins[1]};
    } else {
      const fixed = pins[0].x;
      const min = Math.min(aAdj.y, bAdj.y);
      const max = Math.max(aAdj.y, bAdj.y);
      return {axis:'y', fixed, min, max, wA, wB, pinAStart:pins[0], pinBStart:pins[1]};
    }
  }

  function adjustWireEnd(w, oldEnd, newEnd){
    // replace whichever endpoint equals oldEnd with newEnd
    if(eqPt(w.points[0], oldEnd)) w.points[0] = {...newEnd};
    else if(eqPt(w.points[w.points.length-1], oldEnd)) w.points[w.points.length-1] = {...newEnd};
  }
  function replaceEndpoint(w, oldEnd, newEnd){
    // Replace a matching endpoint in w with newEnd, preserving all other vertices.
    if(eqPt(w.points[0], oldEnd)) {
      w.points[0] = {...newEnd};
      // collapse duplicate vertex if needed
      if(w.points.length>1 && eqPt(w.points[0], w.points[1])) w.points.shift();
    } else if(eqPt(w.points[w.points.length-1], oldEnd)) {
      w.points[w.points.length-1] = {...newEnd};
      if(w.points.length>1 && eqPt(w.points[w.points.length-1], w.points[w.points.length-2])) w.points.pop();
    }
  }

  // Determine axis from a 2-pin part’s pin positions ('x' = horizontal, 'y' = vertical)
  function axisFromPins(pins){
    if(!pins || pins.length<2) return null;
    if(pins[0].y === pins[1].y) return 'x';
    if(pins[0].x === pins[1].x) return 'y';
    return null;
  }
  // Pick the wire at 'pt' that runs along the given axis (ignores branches at junctions)
  function wireAlongAxisAt(pt, axis){
    const ws = wiresEndingAt(pt);
    for(const w of ws){
      const adj = adjacentOther(w, pt);
      if(!adj) continue;
      if(axis==='x' && adj.y === pt.y) return w;   // horizontal wire
      if(axis==='y' && adj.x === pt.x) return w;   // vertical wire
    }
    return null;
  }  

  // ------- Lightweight DOM updaters (avoid full redraw during drag) -------
  function updateComponentDOM(c){
    const g = gComps.querySelector(`g.comp[data-id="${c.id}"]`); if(!g) return;
    // selection outline & hit rect
    const outline = g.querySelector('[data-outline]');
    if(outline){ outline.setAttribute('cx', c.x); outline.setAttribute('cy', c.y); }
    const hit = g.querySelector('rect');
    if(hit){ hit.setAttribute('x', c.x-60); hit.setAttribute('y', c.y-60); }
    // pins
    const pins = compPinPositions(c);
    const pinEls = g.querySelectorAll('circle[data-pin]');
    for(let i=0;i<Math.min(pinEls.length, pins.length);i++){
      pinEls[i].setAttribute('cx', pins[i].x);
      pinEls[i].setAttribute('cy', pins[i].y);
    }
    // Rebuild the inner symbol group so absolute geometry (lines/paths) follows new x/y.
    rebuildSymbolGroup(c, g);
  }

  // Replace the first-level symbol <g> inside a component with a fresh one.
  function rebuildSymbolGroup(c, g){
    const old = g.querySelector(':scope > g'); // the inner symbol group we appended in drawComponent
    const fresh = buildSymbolGroup(c);
    if(old) g.replaceChild(fresh, old); else g.appendChild(fresh);
  }

  function wirePointsString(w){ return w.points.map(p=>`${p.x},${p.y}`).join(' '); }

  function updateWireDOM(w){
    if(!w) return;
    const group = gWires.querySelector(`g[data-id="${w.id}"]`);
    if(!group) return;
    const polys = group.querySelectorAll('polyline');
    const pts = wirePointsString(w);
    polys.forEach(pl=> pl.setAttribute('points', pts));
  }  

  // ====== Interaction ======
  svg.addEventListener('pointerdown', (e)=>{
    const p = svgPoint(e);
    const x = snap(p.x), y=snap(p.y);
    // Middle mouse drag pans
    if (e.button === 1){
      e.preventDefault(); beginPan(e);
      return;
    }
    // Right-click ends wire placement (when wiring)
    if (e.button === 2 && mode==='wire' && drawing.active){
      e.preventDefault();
      suppressNextContextMenu = true; // ensure the imminent contextmenu is blocked
      finishWire();
      return;
    }       
    if(mode==='place' && placeType){
      const id = uid(placeType);
      const labelPrefix = {resistor:'R', capacitor:'C', inductor:'L', diode:'D', npn:'Q', pnp:'Q', ground:'GND', battery:'BT', ac:'AC'}[placeType] || 'X';
      // If a 2-pin part is dropped near a segment, project to it and align rotation
      let at = {x, y}, rot=0;
      if(isTwoPinType(placeType)){
        const hit = nearestSegmentAtPoint(p, 18);
        if(hit){ at = hit.q; rot = normDeg(hit.angle); }
      }
      const comp = { id, type:placeType, x:at.x, y:at.y, rot, label:`${labelPrefix}${counters[placeType]-1}`, value:'', props:{} };
      if(placeType==='diode'){ comp.props.subtype = diodeSubtype; }
      components.push(comp);
      // Break wires at pins and remove inner bridge segment for 2-pin parts
      breakWiresForComponent(comp);
      deleteBridgeBetweenPins(comp);      
      setMode('select'); placeType=null; selection={kind:'component', id}; redraw();
      return;
    }
    if(mode==='wire'){
      // start drawing if not active, else add point
      if(!drawing.active){ 
        drawing.active=true; drawing.points=[{x,y}]; drawing.cursor={x,y};
      } else {
        drawing.points.push({x,y});
      }
      renderDrawing();
    }
    if(mode==='select' && e.button===0){
      // Start marquee only if pointerdown is on empty canvas; defer clearing until mouseup if it's just a click
      const onComp = e.target.closest && e.target.closest('g.comp');
      const onWire = e.target.closest && e.target.closest('#wires g');
      if(!onComp && !onWire){
        beginMarqueeAt(svgPoint(e), /*startedOnEmpty=*/true, /*preferComponents=*/e.shiftKey);
      }
    }    
    if(mode==='pan' && e.button===0){
      beginPan(e);
      return;
    }    
  });

  svg.addEventListener('dblclick', (e)=>{
    if(mode==='wire' && drawing.active){ finishWire(); }
  });
  // Rubber-band wire, placement ghost, crosshair, and hover pan cursor
  svg.addEventListener('pointermove', (e)=>{
    const p = svgPoint(e);
    const x = snap(p.x), y = snap(p.y);
    if (isPanning){ doPan(e); return; }
    // Marquee update (Select mode). Track Shift to flip priority while dragging.
    if(marquee.active){
      marquee.shiftPreferComponents = !!e.shiftKey;
      updateMarqueeTo(svgPoint(e));
    }  
    if(mode==='wire' && drawing.active){
      drawing.cursor = {x, y};
      renderDrawing();
    } else {
      drawing.cursor = null;
    }
    if(mode==='place' && placeType){
      renderGhostAt({x, y}, placeType);
    } else {
      clearGhost();
    }
    // crosshair overlay while in wire mode (even if not actively drawing)
    if(mode==='wire'){ renderCrosshair(x,y); } else { clearCrosshair(); }    
  });

  svg.addEventListener('pointerup', (e)=>{
    // Finish marquee selection if active; otherwise just end any pan
    if(marquee.active){ finishMarquee(); }
    endPan();
  });
  svg.addEventListener('pointerleave', (e)=>{ endPan(); });
  // Ensure middle-click doesn't trigger browser autoscroll and supports pan in all browsers
  svg.addEventListener('mousedown', (e)=>{ if(e.button===1){ e.preventDefault(); beginPan(e); } });
  svg.addEventListener('auxclick', (e)=>{ if(e.button===1){ e.preventDefault(); } });
  // Suppress native context menu while finishing wire with right-click
  // Suppress native context menu right after a right-click wire finish
  svg.addEventListener('contextmenu', (e)=>{
    if (mode==='wire' && (drawing.active || suppressNextContextMenu)) {
      e.preventDefault();
      suppressNextContextMenu = false; // one-shot
    }
  });
  // Zoom on wheel, centered on mouse location (keeps mouse position stable in view)
  svg.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const scale = (e.deltaY < 0) ? 1.1 : (1/1.1);
    const oldZoom = zoom;
    const newZoom = clamp(oldZoom * scale, 0.25, 8);
    if (newZoom === oldZoom) return;
    // focal point in svg coords
    const fp = svgPoint(e);
    // Use current/effective view sizes to avoid jumps on non-16:10 canvases
    const oldW = viewW, oldH = viewH;
    const vw = Math.max(1, svg.clientWidth), vh = Math.max(1, svg.clientHeight);
    const aspect = vw / vh;
    const newW = (BASE_W / newZoom);
    const newH = newW / aspect;    
    viewX = fp.x - (fp.x - viewX) * (newW / oldW);
    viewY = fp.y - (fp.y - viewY) * (newH / oldH);
    zoom = newZoom; 
    applyZoom();
  }, {passive:false});  

  window.addEventListener('keydown', (e)=>{
    if(e.key==='Escape'){
      if(drawing.active){ drawing.active=false; drawing.points=[]; gDrawing.replaceChildren(); }
    }
    if(e.key==='Enter' && drawing.active){ finishWire(); }
    if(e.key.toLowerCase()==='w'){ setMode('wire'); }
    if(e.key.toLowerCase()==='v'){ setMode('select'); }
    if(e.key.toLowerCase()==='p'){ setMode('pan'); }
    if(e.key.toLowerCase()==='m'){ setMode('move'); }
    if(e.key.toLowerCase()==='r'){
      rotateSelected();
    }
    if(e.key==='Delete'){
      if(selection.kind==='component'){ removeComponent(selection.id); }
      if(selection.kind==='wire'){
        const w = wires.find(x=>x.id===selection.id);
        if(w && Number.isInteger(selection.segIndex)){
          removeWireSegment(w, selection.segIndex);
        }else{
          wires = wires.filter(x=>x.id!==selection.id);
          selection={kind:null,id:null,segIndex:null}; redraw();
        }
      }      
    }
    // Arrow-key move in Move mode
    if(mode==='move' && selection.kind==='component'){
      const step = GRID;
      let dx=0, dy=0;
      if(e.key==='ArrowLeft')  dx=-step;
      if(e.key==='ArrowRight') dx= step;
      if(e.key==='ArrowUp')    dy=-step;
      if(e.key==='ArrowDown')  dy= step;
      if(dx!==0 || dy!==0){ e.preventDefault(); moveSelectedBy(dx,dy); }
    }    
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='s'){ e.preventDefault(); saveJSON(); }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='k'){ e.preventDefault(); clearAll(); }
  });

  function finishWire(){
    // Commit only if we have at least one segment
    if(drawing.points.length >= 2){
      // De-dup consecutive identical points to avoid zero-length segments
      const pts = [];
      for(const p of drawing.points){
        if(!pts.length || pts[pts.length-1].x!==p.x || pts[pts.length-1].y!==p.y) pts.push({x:p.x,y:p.y});
      }
      if(pts.length >= 2){
        const id = uid('wire');
        wires.push({ id, points: pts });
        // Post-process: if user placed components while wire was in limbo,
        // split this newly added wire wherever pins land, and remove any inner bridge.
        // (Safe for all components; non-intersecting pins are ignored by the splitter.)
        const comps = components.slice();
        for(const c of comps){
          const didBreak = breakWiresForComponent(c);
          if(didBreak) deleteBridgeBetweenPins(c);
        }
      }
    }
    // Reset drawing state and visuals
    drawing.active = false;
    drawing.points = [];
    drawing.cursor = null;
    gDrawing.replaceChildren();
    clearCrosshair();
    redraw();
  }

  function renderDrawing(){
    gDrawing.replaceChildren();
    if(!drawing.active) return;
    const pts = drawing.cursor ? [...drawing.points, drawing.cursor] : drawing.points;
    const pl = document.createElementNS('http://www.w3.org/2000/svg','polyline');    
    pl.setAttribute('fill','none'); pl.setAttribute('stroke','var(--wire)'); pl.setAttribute('stroke-width','3'); pl.setAttribute('stroke-linecap','round'); pl.setAttribute('stroke-linejoin','round');
    pl.setAttribute('marker-start','url(#dot)');
    pl.setAttribute('points', pts.map(p=>`${p.x},${p.y}`).join(' '));
    gDrawing.appendChild(pl);
  }

  // ----- Crosshair overlay -----
  function clearCrosshair(){
    // Only remove the crosshair lines, not the marquee rect
    [...gOverlay.querySelectorAll('[data-crosshair]')].forEach(el=>el.remove());
  }
  function renderCrosshair(x,y){
    clearCrosshair(); // remove previous crosshair lines, keep marquee intact
    // span the *visible* viewBox, accounting for pan offsets
    const xL = viewX, xR = viewX + viewW;
    const yT = viewY, yB = viewY + viewH;    
    const hline = document.createElementNS('http://www.w3.org/2000/svg','line');
    hline.setAttribute('data-crosshair','1');
    hline.setAttribute('x1', xL); hline.setAttribute('y1', y);
    hline.setAttribute('x2', xR); hline.setAttribute('y2', y);    
    const vline = document.createElementNS('http://www.w3.org/2000/svg','line');
    vline.setAttribute('data-crosshair','1');
    vline.setAttribute('x1', x); vline.setAttribute('y1', yT);
    vline.setAttribute('x2', x); vline.setAttribute('y2', yB);    
    gOverlay.appendChild(hline); gOverlay.appendChild(vline);
  }  

  // ----- Placement ghost -----
  let ghostEl = null;
  function clearGhost(){ if(ghostEl){ ghostEl.remove(); ghostEl=null; } }
  function renderGhostAt(pos, type){
    clearGhost();
    let at = {x:pos.x, y:pos.y}, rot = 0;
    if(isTwoPinType(type)){
      const hit = nearestSegmentAtPoint(pos, 18);
      if(hit){ at = hit.q; rot = normDeg(hit.angle); }
    }
    const ghost = { id:'__ghost__', type, x:at.x, y:at.y, rot, label:'', value:'', props:{} };
    if(type==='diode'){ ghost.props.subtype = diodeSubtype; }    
    ghostEl = drawComponent(ghost);
    ghostEl.style.opacity = '0.5';
    ghostEl.style.pointerEvents = 'none';
    gDrawing.appendChild(ghostEl);
  }  

  function rotateSelected(){
    if(selection.kind!=='component') return;
    const c = components.find(x=>x.id===selection.id); if(!c) return;
    c.rot = (c.rot + 90)%360;
    // After rotation, if pins now cross a wire, split and remove bridge
    if(breakWiresForComponent(c)){
      deleteBridgeBetweenPins(c);
    }    
    redraw();
  }

  // ====== Toolbar ======
  document.getElementById('modeGroup').addEventListener('click', (e)=>{
    const btn = e.target.closest('button'); if(!btn) return;
    const m = btn.dataset.mode; if(!m) return;
    setMode(m);
  });

  // Fallback selection by delegation (ensures inspector opens on click)
  gComps.addEventListener('pointerdown', (e)=>{
    if(!(mode==='select' || mode==='move')) return;
    const compG = e.target.closest('g.comp');
    if(compG){
      const id = compG.getAttribute('data-id');
      selecting('component', id);
      e.stopPropagation();
    }
  });  

  const paletteRow2 = document.getElementById('paletteRow2');
  function positionSubtypeDropdown(){
    if(!paletteRow2) return;
    const headerEl = document.querySelector('header');
    const diodeBtn = document.querySelector('#paletteRow1 button[data-tool="diode"]');
    if(!headerEl || !diodeBtn) return;
    const hb = headerEl.getBoundingClientRect();
    const bb = diodeBtn.getBoundingClientRect();
    // Position just under the Diode button, with a small vertical gap
    paletteRow2.style.left = (bb.left - hb.left) + 'px';
    paletteRow2.style.top  = (bb.bottom - hb.top + 6) + 'px';
  }
  window.addEventListener('resize', ()=>{ if(paletteRow2.style.display!=='none') positionSubtypeDropdown(); });

  document.getElementById('paletteRow1').addEventListener('click', (e)=>{
    const btn = e.target.closest('button'); if(!btn) return;
    placeType = btn.dataset.tool; setMode('place');
    // Reveal sub-type row only for types that have subtypes (currently: diode)
    if (placeType === 'diode') {
      paletteRow2.style.display = 'block';
      // keep dropdown reflecting last chosen subtype
      const ds = document.getElementById('diodeSelect'); if (ds) ds.value = diodeSubtype;
      positionSubtypeDropdown();
    } else {
      paletteRow2.style.display = 'none';
    }    
  });
  // Diode subtype select → enter Place mode for diode using chosen subtype
  const diodeSel = document.getElementById('diodeSelect');
  if (diodeSel){
    diodeSel.value = diodeSubtype;
    diodeSel.addEventListener('change', ()=>{
      diodeSubtype = diodeSel.value || 'generic';
      placeType = 'diode'; setMode('place');
      // ensure the subtype row is visible while placing diodes
      paletteRow2.style.display = 'block';
      positionSubtypeDropdown();      
    });
    // clicking the dropdown should also arm diode placement without changing the value
    diodeSel.addEventListener('mousedown', ()=>{
      placeType='diode'; setMode('place');
      paletteRow2.style.display = 'block';
      positionSubtypeDropdown();
    });
  }

  document.getElementById('rotateBtn').addEventListener('click', rotateSelected);

  document.getElementById('clearBtn').addEventListener('click', clearAll);

  // Zoom controls
  document.getElementById('zoomInBtn').addEventListener('click', ()=>{ zoom = Math.min(8, zoom*1.25); applyZoom(); });
  document.getElementById('zoomOutBtn').addEventListener('click', ()=>{ zoom = Math.max(0.25, zoom/1.25); applyZoom(); });
  document.getElementById('zoomResetBtn').addEventListener('click', ()=>{ zoom = 1; applyZoom(); viewX=0; viewY=0; applyZoom(); });
  document.getElementById('zoomPct').addEventListener('change', (e)=>{
    const raw = (e.target.value || '').trim();
    const n = raw.endsWith('%') ? parseFloat(raw) / 100 : parseFloat(raw);
    if (!isFinite(n) || n <= 0) { updateZoomUI(); return; }
    zoom = clamp(n, 0.25, 8); applyZoom();
  });

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  // Pan helpers
  let isPanning = false, panStartSvg = null, panStartView = null, panPointerId = null;
  function beginPan(e){
    isPanning = true;
    document.body.classList.add('panning');
    const p = svgPoint(e);
    panStartSvg = {x:p.x, y:p.y};
    panStartView = {x:viewX, y:viewY};
    panPointerId = e.pointerId;
    svg.setPointerCapture?.(panPointerId);
  }
  function doPan(e){
    if(!isPanning) return;
    const p = svgPoint(e);
    const dx = p.x - panStartSvg.x;
    const dy = p.y - panStartSvg.y;
    viewX = panStartView.x - dx;
    viewY = panStartView.y - dy;
    applyZoom();  // updates grid to fill viewport
  }
  function endPan(){
    if(!isPanning) return;
    isPanning = false;
    document.body.classList.remove('panning');
    if(panPointerId!=null) svg.releasePointerCapture?.(panPointerId);
    panPointerId = null;
  }  

  function clearAll(){
    if(!confirm('Clear the canvas? This cannot be undone.')) return;
    components = [];
    wires = [];
    selection = {kind:null, id:null, segIndex:null};
    // Cancel any in-progress wire drawing and clear overlay
    drawing.active = false;
    drawing.points = [];
    gDrawing.replaceChildren();
    // Reset ID counters
    counters = { resistor:1, capacitor:1, inductor:1, diode:1, npn:1, pnp:1, ground:1, battery:1, ac:1, wire:1 };
    redraw();
  }

  // ====== Inspector ======
  function renderInspector(){
    inspector.replaceChildren();
    const sel = selection.kind==='component' && components.find(c=>c.id===selection.id);
    inspectorNone.style.display = sel? 'none' : 'block';
    if(!sel) return;
    const c = sel;
    const wrap = document.createElement('div');

    wrap.appendChild(rowPair('ID', text(c.id, true)));
    wrap.appendChild(rowPair('Type', text(c.type, true)));

    wrap.appendChild(rowPair('Label', input(c.label, v=>{ c.label=v; redrawCanvasOnly(); } )));

    // value field for generic components
    const showValue = ['resistor','capacitor','inductor','diode'].includes(c.type);
    // Value + Unit (inline) for R, C, L. (Diode keeps a simple Value field if desired.)
    if(c.type==='resistor' || c.type==='capacitor' || c.type==='inductor'){
      if(!c.props) c.props = {};
      const typeKey = c.type;
      const container = document.createElement('div');
      container.className = 'hstack';      
      // numeric / text value
      const valInput = document.createElement('input');
      valInput.type = 'text';
      valInput.value = c.value || '';
      valInput.oninput = ()=>{ c.value = valInput.value; redrawCanvasOnly(); };
      // unit select (uses symbols, e.g., kΩ, µF, mH)
      const sel = unitSelect(typeKey, (c.props.unit) || defaultUnit(typeKey), (u)=>{
        c.props.unit = u; redrawCanvasOnly();
      });
      container.appendChild(valInput);
      container.appendChild(sel);
      wrap.appendChild(rowPair('Value', container));
    } else if (c.type==='diode'){
      // Value (optional text) for diode
      wrap.appendChild(rowPair('Value', input(c.value||'', v=>{ c.value=v; redrawCanvasOnly(); } )));
      // Subtype (editable)
      const subSel = document.createElement('select');
      ['generic','schottky','zener','led','photo','tunnel','varactor','laser'].forEach(v=>{
        const o=document.createElement('option'); o.value=v;
        o.textContent = ({
          generic:'Generic', schottky:'Schottky', zener:'Zener',
          led:'Light-emitting (LED)', photo:'Photo', tunnel:'Tunnel',
          varactor:'Varactor / Varicap', laser:'Laser'
        })[v]; subSel.appendChild(o);
      });
      subSel.value = (c.props && c.props.subtype) ? c.props.subtype : 'generic';
      subSel.onchange = ()=>{
        if(!c.props) c.props = {};
        c.props.subtype = subSel.value;
        // also remember for palette placements
        diodeSubtype = subSel.value;
        redrawCanvasOnly();
      };
      wrap.appendChild(rowPair('Subtype', subSel));      
    }

    // voltage for DC battery & AC source
    if(c.type==='battery' || c.type==='ac'){
      if(!c.props) c.props = {};
      wrap.appendChild(rowPair('Voltage (V)', number(c.props.voltage ?? 0, v=>{ c.props.voltage=v; redrawCanvasOnly(); } )));
    }
    // position + rotation
    wrap.appendChild(rowPair('X', number(c.x, v=>{ c.x = snap(v); redrawCanvasOnly(); } )));
    wrap.appendChild(rowPair('Y', number(c.y, v=>{ c.y = snap(v); redrawCanvasOnly(); } )));
    wrap.appendChild(rowPair('Rotation', number(c.rot, v=>{ c.rot = (Math.round(v/90)*90)%360; redrawCanvasOnly(); } )));

    inspector.appendChild(wrap);
    // After the DOM is in place, size any Value/Units selects to their content (capped at 50%)
    fitInspectorUnitSelects();    
  }

  function rowPair(lbl, control){
    const d1=document.createElement('div'); d1.className='row';
    const l=document.createElement('label'); l.textContent=lbl; l.style.width='90px'; d1.appendChild(l);
    d1.appendChild(control); return d1;
  }
  function input(val, on){ const i=document.createElement('input'); i.type='text'; i.value=val; i.oninput=()=>on(i.value); return i; }
  function number(val, on){ const i=document.createElement('input'); i.type='number'; i.value=val; i.oninput=()=>on(parseFloat(i.value)||0); return i; }
  function text(val, readonly=false){ const i=document.createElement('input'); i.type='text'; i.value=val; i.readOnly=readonly; return i; }
  function unitSelect(kind, current, onChange){
    const sel = document.createElement('select');
    (UNIT_OPTIONS[kind]||[]).forEach(u=>{
      const opt=document.createElement('option'); opt.value=u; opt.textContent=u; sel.appendChild(opt);
    });
    sel.value = current || defaultUnit(kind);
    sel.onchange = ()=> onChange(sel.value);
    return sel;
  }
  // === Size the units <select> to longest option text (but ≤ 50% of container width) ===
  function fitInspectorUnitSelects(){
    const sels = inspector.querySelectorAll('.hstack select');
    sels.forEach(sizeUnitSelectToContent);
  }
  function sizeUnitSelectToContent(sel){
    // Only size units inside a value row (class 'hstack'); skip other selects (e.g., diode subtype)
    const row = sel.closest('.hstack'); if(!row) return;
    // Measure longest option text using canvas with the select's computed font
    const cs = getComputedStyle(sel);
    const font = cs.font || `${cs.fontStyle} ${cs.fontVariant} ${cs.fontWeight} ${cs.fontSize}/${cs.lineHeight} ${cs.fontFamily}`;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = font;
    let maxText = 0;
    Array.from(sel.options).forEach(o=>{
      const w = ctx.measureText(o.textContent || '').width;
      if (w > maxText) maxText = w;
    });
    // Account for select paddings + arrow affordance (~36px is a good cross-browser fudge)
    const pad = 36;
    const desired = Math.ceil(maxText + pad);
    // Cap at 50% of the row's width
    const rowW = row.getBoundingClientRect().width || 0;
    const cap = Math.max(0, Math.floor(rowW * 0.5));
    const finalW = Math.min(desired, cap);
    sel.style.width = finalW > 0 ? `${finalW}px` : 'auto';
  }
  // Re-fit on window resize (pane widths can change)
  window.addEventListener('resize', ()=>{
    // Only run if the inspector is showing something
    if (inspector && inspector.childElementCount) fitInspectorUnitSelects();
  });
  function defaultUnit(kind){
    if(kind==='resistor') return '\u03A9'; // Ω
    if(kind==='capacitor') return 'F';
    if(kind==='inductor') return 'H';
    return '';
  }
  // ====== Embed / overlap helpers ======
  function isEmbedded(c){
    const pins = compPinPositions(c).map(p=>({x:snap(p.x),y:snap(p.y)}));
    if(pins.length<2) return false;
    return wiresEndingAt(pins[0]).length===1 && wiresEndingAt(pins[1]).length===1;
  }
  function overlapsAnyOther(c){
    const R = 56; // same as selection outline radius
    for(const o of components){
      if(o.id===c.id) continue;
      const dx = o.x - c.x, dy = o.y - c.y;
      if((dx*dx + dy*dy) < (R*R)) return true;
    }
    return false;
  }  

  // ====== Move helpers (mouse drag already handled; this handles arrow keys & clamping) ======
  function moveSelectedBy(dx, dy){
    const c = components.find(x=>x.id===selection.id); if(!c) return;
    const ctx = buildSlideContext(c);
    if(ctx){
      // slide along constrained axis
      if(ctx.axis==='x'){
        let nx = snap(c.x + dx);
        nx = Math.max(Math.min(ctx.max, nx), ctx.min);
        c.x = nx; c.y = ctx.fixed;
      }else{
        let ny = snap(c.y + dy);
        ny = Math.max(Math.min(ctx.max, ny), ctx.min);
        c.y = ny; c.x = ctx.fixed;
      }
      const pins = compPinPositions(c).map(p=>({x:snap(p.x),y:snap(p.y)}));
      adjustWireEnd(ctx.wA, ctx.pinAStart, pins[0]);
      adjustWireEnd(ctx.wB, ctx.pinBStart, pins[1]);
      ctx.pinAStart = pins[0]; ctx.pinBStart = pins[1];
      redraw();
    }else{
      c.x = snap(c.x + dx); c.y = snap(c.y + dy);
      redrawCanvasOnly();
    }
  }

  // --- Mend helpers ---
  function indexOfPoint(pts, p){
    for(let i=0;i<pts.length;i++){ if(pts[i].x===p.x && pts[i].y===p.y) return i; }
    return -1;
  }
  // Return a copy whose LAST point is 'pin'. If 'pin' is interior, keep only the side up to the pin.
  function orderPointsEndingAt(pts, pin){
    const n = pts.length;
    if(n===0) return pts.slice();
    if(pts[n-1].x===pin.x && pts[n-1].y===pin.y) return pts.slice();
    if(pts[0].x===pin.x && pts[0].y===pin.y) return pts.slice().reverse();
    const k = indexOfPoint(pts, pin);
    return (k>=0) ? pts.slice(0, k+1) : pts.slice();
  }
  // Return a copy whose FIRST point is 'pin'. If 'pin' is interior, keep only the side from the pin.
  function orderPointsStartingAt(pts, pin){
    const n = pts.length;
    if(n===0) return pts.slice();
    if(pts[0].x===pin.x && pts[0].y===pin.y) return pts.slice();
    if(pts[n-1].x===pin.x && pts[n-1].y===pin.y) return pts.slice().reverse();
    const k = indexOfPoint(pts, pin);
    return (k>=0) ? pts.slice(k) : pts.slice();
  }
  function collapseDuplicateVertices(pts){
    const out=[]; for(const p of pts){
      const last = out[out.length-1];
      if(!last || last.x!==p.x || last.y!==p.y) out.push({x:p.x, y:p.y});
    }
    return out;
  }
  // Helpers to validate/normalize wire polylines
  function samePt(a,b){ return !!a && !!b && a.x===b.x && a.y===b.y; }
  function normalizedPolylineOrNull(pts){
    const c = collapseDuplicateVertices(pts||[]);
    if (c.length < 2) return null;
    if (c.length === 2 && samePt(c[0], c[1])) return null; // zero-length line
    return c;
  }
  function normalizeAllWires(){
    wires = wires.reduce((acc,w)=>{
      const c = normalizedPolylineOrNull(w.points);
      if (c) acc.push({ id: w.id, points: c });
      return acc;
    }, []);
  }  

  // ====== Save / Load ======
  document.getElementById('saveBtn').addEventListener('click', saveJSON);
  document.getElementById('loadBtn').addEventListener('click', ()=> document.getElementById('fileInput').click());
  document.getElementById('fileInput').addEventListener('change', (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    const reader = new FileReader();
    reader.onload = ()=>{ try{ loadFromJSON(reader.result); } catch(err){ alert('Failed to load JSON: '+err); } };
    reader.readAsText(f);
  });

  function saveJSON(){
    // Clean up any accidental duplicates/zero-length segments before saving
    normalizeAllWires();    
    const data = {
      version: 1,
      title: projTitle.value || 'Untitled',
      grid: GRID,
      components,
      wires
    };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (projTitle.value?.trim()||'schematic') + '.json';
    document.body.appendChild(a); a.click(); a.remove();
  }

  function loadFromJSON(text){
    const data = JSON.parse(text);
    components = data.components||[]; wires = data.wires||[]; projTitle.value = data.title||'';
    normalizeAllWires();
    // re-seed counters so new IDs continue incrementing nicely
    const used = { resistor:0, capacitor:0, inductor:0, diode:0, npn:0, pnp:0, ground:0, battery:0, ac:0, wire:0 };
    for(const c of components){ const k=c.type; const num=parseInt((c.label||'').replace(/^[A-Z]+/,'').trim())||0; used[k]=Math.max(used[k], num); }
    for(const w of wires){ const n=parseInt((w.id||'').replace(/^wire/,''))||0; used.wire=Math.max(used.wire,n); }
    Object.keys(counters).forEach(k=> counters[k] = used[k]+1 );
    selection={kind:null, id:null, segIndex:null}; redraw();
  }

  // ====== Boot ======
  // start at 1:1
  applyZoom();
  redraw();
})();
</script>
</body>
</html>
